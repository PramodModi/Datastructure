<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convert Binary Search Tree to Sorted Doubly Linked List</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            color: #333;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 8px;
        }
        .problem {
            background-color: #f0f8ff;
            border-left: 5px solid #4682b4;
        }
        .understanding {
            background-color: #f0fff0;
            border-left: 5px solid #2e8b57;
        }
        .approach {
            background-color: #fff0f5;
            border-left: 5px solid #db7093;
        }
        .steps {
            background-color: #fff8dc;
            border-left: 5px solid #daa520;
        }
        .code {
            background-color: #f8f8ff;
            border-left: 5px solid #6a5acd;
        }
        pre {
            background-color: #1e1e1e;
            color: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }
        pre .comment {
            color: #6a9955;
            font-style: italic;
        }
        pre.command {
            background-color: #1e1e1e;
            color: #66d9ef;
            font-weight: 500;
        }
        pre.command .comment {
            color: #7c7c7c;
            font-style: italic;
        }
        h2 {
            color: #444;
            border-bottom: 2px solid #ddd;
            padding-bottom: 5px;
        }
        .example {
            background-color: #f9f9f9;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 3px solid #666;
        }
        .output {
            background-color: #e6f7ff;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 3px solid #1890ff;
        }
        .key-insight {
            background-color: #fffbe6;
            border-left: 5px solid #faad14;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .visualization {
            background-color: #f9f0ff;
            border-left: 5px solid #722ed1;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        .complexity {
            background-color: #f0f0f0;
            border-left: 5px solid #708090;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        .tree-diagram {
            text-align: center;
            margin: 20px 0;
            font-family: monospace;
            white-space: pre;
        }
        .linked-list-diagram {
            text-align: center;
            margin: 20px 0;
            font-family: monospace;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>Convert Binary Search Tree to Sorted Doubly Linked List</h1>

    <div class="section problem">
        <h2>Problem</h2>
        <p><strong>Problem Description: Convert Binary Search Tree to Sorted Doubly Linked List</strong></p>
        <p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/" target="_blank">LeetCode 426: https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p>
        <p>
            Convert a Binary Search Tree (BST) to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.
        </p>
        
        <div class="example">
            <p><strong>Example:</strong></p>
            <p>Input:</p>
            <div class="tree-diagram">
                  4
                 / \
                2   5
               / \
              1   3
            </div>
            <p>Output: Sorted Circular Doubly Linked List</p>
            <div class="linked-list-diagram">
            <pre>
              ┌─────┐     ┌─────┐     ┌─────┐     ┌─────┐     ┌─────┐
              │     │◄────┤     │◄────┤     │◄────┤     │◄────┤     │
              │  1  │     │  2  │     │  3  │     │  4  │     │  5  │
              │     ├────►│     ├────►│     ├────►│     ├────►│     │
              └─────┘     └─────┘     └─────┘     └─────┘     └─────┘
                 ▲                                                │
                 │                                                │
                 └────────────────────────────────────────────────┘
            </pre>
            </div>
        </div>
    </div>

    <div class="section understanding">
        <h2>Understanding</h2>
        <p>
            This problem requires us to convert a Binary Search Tree (BST) into a sorted circular doubly-linked list while preserving the original structure of the BST. Let's break down what this means:
        </p>
        
        <ul>
            <li><strong>Binary Search Tree (BST):</strong> A binary tree where the left subtree of a node contains only nodes with values less than the node's value, and the right subtree contains only nodes with values greater than the node's value.</li>
            <li><strong>Doubly-Linked List:</strong> A linked list where each node has two pointers - one to the next node and one to the previous node.</li>
            <li><strong>Circular:</strong> The last node points back to the first node, and the first node points back to the last node.</li>
            <li><strong>Sorted:</strong> The nodes in the linked list should be in ascending order of their values.</li>
            <li><strong>In-place:</strong> We need to reuse the existing nodes without creating new nodes.</li>
        </ul>
        
        <p>
            For the conversion:
        </p>
        <ul>
            <li>The left pointer of a node becomes the previous pointer in the doubly-linked list.</li>
            <li>The right pointer of a node becomes the next pointer in the doubly-linked list.</li>
        </ul>
        
        <p>
            Let's understand this with our example:
        </p>
        
        <div class="tree-diagram">
            <p>BST:</p>
            <pre>
                  4
                 / \
                2   5
               / \
              1   3
            </pre>
        </div>
        
        <p>
            When we convert this BST into a sorted doubly-linked list, we want to arrange the nodes in ascending order: 1 → 2 → 3 → 4 → 5.
            Since it's circular, the last node (5) should point back to the first node (1), and the first node should have a previous pointer to the last node.
        </p>
        
        <div class="linked-list-diagram">
            <p>Sorted Circular Doubly Linked List:</p>
            <pre>
              ┌─────┐     ┌─────┐     ┌─────┐     ┌─────┐     ┌─────┐
              │     │◄────┤     │◄────┤     │◄────┤     │◄────┤     │
              │  1  │     │  2  │     │  3  │     │  4  │     │  5  │
              │     ├────►│     ├────►│     ├────►│     ├────►│     │
              └─────┘     └─────┘     └─────┘     └─────┘     └─────┘
                 ▲                                                │
                 │                                                │
                 └────────────────────────────────────────────────┘
            </pre>
        </div>
        
        <p>
            If we follow the "next" pointers starting from any node, we should cycle through all nodes in ascending order.
            Similarly, if we follow the "previous" pointers, we should cycle through all nodes in descending order.
        </p>
    </div>

    <div class="section approach">
        <h2>Approach: Inorder Traversal</h2>
        <p>
            The key insight for this problem is to use an inorder traversal of the BST. An inorder traversal of a BST visits nodes in ascending order, which is exactly what we need for our sorted doubly-linked list.
        </p>
        
        <div class="key-insight">
            <p><strong>Key Insight:</strong> Inorder traversal of a BST yields nodes in ascending order, which is perfect for creating a sorted linked list.</p>
        </div>
        
        <p>The approach is as follows:</p>
        <ol>
            <li>Perform an inorder traversal of the BST.</li>
            <li>As we visit each node, connect it to the previously visited node and update our "previous" pointer.</li>
            <li>Keep track of the first node (head) of the linked list.</li>
            <li>After traversal, connect the first and last nodes to make the list circular.</li>
        </ol>

        <div class="steps">
            <h3>Steps:</h3>
            <ol>
                <li>
                    <strong>Handle Edge Cases:</strong>
                    <ul>
                        <li>If the BST is empty (root is NULL), return NULL.</li>
                    </ul>
                </li>
                <li>
                    <strong>Initialize Variables:</strong>
                    <ul>
                        <li>Initialize `head` to NULL to store the first node of the linked list.</li>
                        <li>Initialize `prev` to NULL to keep track of the previously visited node during traversal.</li>
                    </ul>
                </li>
                <li>
                    <strong>Inorder Traversal:</strong>
                    <ul>
                        <li>Define a recursive inorder traversal function that:
                            <ul>
                                <li>Recursively processes the left subtree.</li>
                                <li>Processes the current node:
                                    <ul>
                                        <li>If `prev` is not NULL, connect it with the current node.</li>
                                        <li>If `prev` is NULL (first node), set `head` to the current node.</li>
                                        <li>Update `prev` to the current node.</li>
                                    </ul>
                                </li>
                                <li>Recursively processes the right subtree.</li>
                            </ul>
                        </li>
                        <li>Call the inorder traversal function with the root node.</li>
                    </ul>
                </li>
                <li>
                    <strong>Make the Linked List Circular:</strong>
                    <ul>
                        <li>Connect the last node (pointed to by `prev`) with the first node (`head`) to make the list circular.</li>
                    </ul>
                </li>
                <li>
                    <strong>Return the Head of the Linked List:</strong>
                    <ul>
                        <li>Return `head` as the start of the circular doubly-linked list.</li>
                    </ul>
                </li>
            </ol>
        </div>

        <div class="visualization">
            <p><strong>Visualization for Example:</strong></p>
            <pre>
BST:
      4
     / \
    2   5
   / \
  1   3

Inorder Traversal Execution:
- Start at root (4)
- Recursively visit left subtree (2)
  - Recursively visit left subtree (1)
    - No left child, process node 1
    - head = 1, prev = 1
    - No right child, return
  - Process node 2
    - Connect: 1.right = 2, 2.left = 1
    - Update: prev = 2
  - Recursively visit right subtree (3)
    - No left child, process node 3
    - Connect: 2.right = 3, 3.left = 2
    - Update: prev = 3
    - No right child, return
  - Return to node 4
- Process node 4
  - Connect: 3.right = 4, 4.left = 3
  - Update: prev = 4
- Recursively visit right subtree (5)
  - No left child, process node 5
  - Connect: 4.right = 5, 5.left = 4
  - Update: prev = 5
  - No right child, return
- Traversal complete, prev = 5

Make circular:
- Connect: 5.right = 1, 1.left = 5

Final Doubly Linked List (head = 1):
1 ⟷ 2 ⟷ 3 ⟷ 4 ⟷ 5
↑                   ↓
└───────────────────┘
</pre>
        </div>

        <div class="complexity">
            <h3>Complexity Analysis:</h3>
            <ul>
                <li><strong>Time Complexity:</strong> O(n), where n is the number of nodes in the BST. We need to visit each node exactly once during the inorder traversal.</li>
                <li><strong>Space Complexity:</strong> O(h), where h is the height of the BST. This is due to the recursive call stack during the inorder traversal. In the worst case, for a skewed tree, h = n, making the space complexity O(n). For a balanced BST, h = log(n), resulting in O(log n) space complexity.</li>
                <li><strong>Note:</strong> The problem specifies an "in-place" conversion, which means we reuse the existing nodes without allocating new memory for the linked list. We only change the pointers.</li>
            </ul>
        </div>
    </div>

    <div class="section code">
        <h2>Code</h2>
        <pre>
class Node:
    def __init__(self, val, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def treeToDoublyLinkedList(root):
    <span class="comment">"""Convert a binary search tree to a sorted circular doubly-linked list in-place.
    
    Args:
        root: The root of the binary search tree
        
    Returns:
        The head of the sorted circular doubly-linked list
    """</span>
    <span class="comment"># Handle empty tree</span>
    if not root:
        return None
    
    <span class="comment"># Initialize head and prev pointers</span>
    head, prev = None, None
    
    def inOrder(node):
        <span class="comment">"""Helper function for inorder traversal."""</span>
        if node is None:
            return
        
        <span class="comment"># Traverse the left subtree</span>
        inOrder(node.left)
        
        <span class="comment"># Process the current node</span>
        nonlocal head, prev
        if prev:
            <span class="comment"># Connect the previous node with the current node</span>
            prev.right = node
            node.left = prev
        else:
            <span class="comment"># First node becomes the head</span>
            head = node
        
        <span class="comment"># Update the previous node to the current node</span>
        prev = node
        
        <span class="comment"># Traverse the right subtree</span>
        inOrder(node.right)
    
    <span class="comment"># Perform inorder traversal</span>
    inOrder(root)
    
    <span class="comment"># Connect the first and last nodes to make the list circular</span>
    prev.right = head
    head.left = prev
    
    return head

def printCircularLinkedList(head):
    <span class="comment">"""Print the values of a circular linked list."""</span>
    if head is None:
        return None
    
    cur = head
    print(cur.val)
    cur = cur.right
    
    while cur != head:
        print(cur.val)
        cur = cur.right</pre>
        
        <div class="example">
            <p><strong>Example:</strong></p>
            <pre class="command">root = Node(4, Node(2, Node(1), Node(3)), Node(5))
head = treeToDoublyLinkedList(root)
printCircularLinkedList(head)  <span class="comment"># Output: 1, 2, 3, 4, 5</span></pre>
        </div>
        
        <div class="output">
            <p><strong>Output:</strong></p>
            <pre class="command">1
2
3
4
5</pre>
        </div>
    </div>

    <div class="section applications">
        <h2>Applications and Extensions</h2>
        <p>
            This problem is a classic example of tree transformation and showcases the power of inorder traversal in BST operations. It has several practical applications and can be extended in various ways:
        </p>
        <ol>
            <li>
                <strong>Memory-Efficient Tree Traversal:</strong>
                <p>Converting a tree to a linked list can be useful for memory-efficient sequential access to tree nodes.</p>
            </li>
            <li>
                <strong>Tree Flattening:</strong>
                <p>This is a specific case of tree flattening, which is useful in various algorithm designs and data structure transformations.</p>
            </li>
            <li>
                <strong>Variations:</strong>
                <p>
                    Several variations of this problem exist:
                </p>
                <ul>
                    <li>Converting a BST to a singly-linked list.</li>
                    <li>Converting a general binary tree (not necessarily a BST) to a linked list with different traversal orders.</li>
                    <li>Flattening a tree into a linked list without using extra space (in-place operation).</li>
                </ul>
            </li>
            <li>
                <strong>Morris Traversal:</strong>
                <p>For even more memory efficiency, the Morris traversal technique can be used to achieve O(1) space complexity without using recursion or a stack.</p>
            </li>
        </ol>
    </div>
</body>
</html>
