<!DOCTYPE html>
<html>
<head>
    <title>Middle of the Linked List - Fast & Slow Pointers Solution</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #3498db;
            margin-top: 20px;
        }
        h3 {
            color: #2980b9;
        }
        .code-block {
            background-color: #1e1e1e;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            margin: 15px 0;
        }
        .comment {
            color: #75715e;
        }
        .example {
            background-color: #f9f9f9;
            border-left: 4px solid #3498db;
            padding: 10px 20px;
            margin: 20px 0;
        }
        .visualization {
            margin: 20px 0;
            overflow-x: auto;
        }
        .step-block {
            background-color: #f8f9fa;
            border-left: 4px solid #28a745;
            padding: 10px 20px;
            margin: 20px 0;
        }
        .highlight {
            background-color: #ffffcc;
            padding: 2px 4px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .slow {
            color: #e74c3c;
            font-weight: bold;
        }
        .fast {
            color: #3498db;
            font-weight: bold;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
        }
        .node {
            display: inline-block;
            width: 40px;
            height: 40px;
            line-height: 40px;
            border-radius: 50%;
            text-align: center;
            background-color: #3498db;
            color: white;
            margin: 5px;
            position: relative;
        }
        .node-link {
            display: inline-block;
            width: 30px;
            border-top: 2px solid #2c3e50;
            margin: 0 -2px;
            position: relative;
            top: -15px;
        }
        .slow-pointer {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: #e74c3c;
            font-weight: bold;
        }
        .fast-pointer {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            color: #3498db;
            font-weight: bold;
        }
        .highlighted {
            background-color: #2ecc71;
        }
    </style>
</head>
<body>

<h1>Middle of the Linked List - Fast & Slow Pointers Solution</h1>

<p>Problem URL: <a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank">LeetCode - 876. Middle of the Linked List</a></p>

<h2>Problem Statement</h2>

<p>Given the head of a singly linked list, return the middle node of the linked list.</p>

<p>If there are two middle nodes, return the second middle node.</p>

<div class="example">
    <h3>Example 1:</h3>
    <p><strong>Input:</strong> head = [1,2,3,4,5]</p>
    <p><strong>Output:</strong> [3,4,5]</p>
    <p><strong>Explanation:</strong> The middle node of the list is node 3.</p>
</div>

<div class="example">
    <h3>Example 2:</h3>
    <p><strong>Input:</strong> head = [1,2,3,4,5,6]</p>
    <p><strong>Output:</strong> [4,5,6]</p>
    <p><strong>Explanation:</strong> Since the list has two middle nodes with values 3 and 4, we return the second one.</p>
</div>

<h2>Understanding the Problem</h2>

<p>We are given a singly linked list and asked to find the middle node. If the list has an odd number of nodes, there is a unique middle node. If the list has an even number of nodes, there are two middle nodes, and we need to return the second one.</p>

<p>For example:</p>
<ul>
    <li>For a list with 5 nodes: 1 → 2 → 3 → 4 → 5, the middle node is 3.</li>
    <li>For a list with 6 nodes: 1 → 2 → 3 → 4 → 5 → 6, the middle nodes are 3 and 4, but we return 4.</li>
</ul>

<h2>Approach: Fast & Slow Pointers</h2>

<p>The optimal approach for solving this problem is using the Fast & Slow Pointers pattern:</p>

<ol>
    <li>Initialize two pointers, <span class="slow">slow</span> and <span class="fast">fast</span>, both pointing to the head of the linked list.</li>
    <li>Move the <span class="slow">slow pointer</span> one step at a time (slow = slow.next).</li>
    <li>Move the <span class="fast">fast pointer</span> two steps at a time (fast = fast.next.next).</li>
    <li>Continue moving both pointers until the <span class="fast">fast pointer</span> reaches the end of the list (either fast becomes null or fast.next becomes null).</li>
    <li>When the <span class="fast">fast pointer</span> reaches the end, the <span class="slow">slow pointer</span> will be at the middle of the list.</li>
</ol>

<div class="step-block">
    <h3>Why This Approach Works</h3>
    <p>Since the <span class="fast">fast pointer</span> moves twice as fast as the <span class="slow">slow pointer</span>, by the time the <span class="fast">fast pointer</span> reaches the end of the list, the <span class="slow">slow pointer</span> will have moved halfway through the list, which is exactly the middle.</p>
    <p>For an odd number of nodes, when the <span class="fast">fast pointer</span> reaches the last node, the <span class="slow">slow pointer</span> will be at the middle node.</p>
    <p>For an even number of nodes, when the <span class="fast">fast pointer</span> moves past the last node (becomes null), the <span class="slow">slow pointer</span> will be at the second middle node, which is what we want.</p>
</div>

<h2>Algorithm</h2>

<ol>
    <li>Initialize <span class="slow">slow</span> and <span class="fast">fast</span> pointers to the head of the linked list.</li>
    <li>If the list has only one node (head.next is null), return the <span class="slow">slow pointer</span>.</li>
    <li>While <span class="fast">fast pointer</span> is not null and <span class="fast">fast pointer's next</span> is not null:
        <ul>
            <li>Move <span class="slow">slow pointer</span> one step ahead: <code>slow = slow.next</code></li>
            <li>Move <span class="fast">fast pointer</span> two steps ahead: <code>fast = fast.next.next</code></li>
        </ul>
    </li>
    <li>Return the <span class="slow">slow pointer</span>, which is now at the middle of the list.</li>
</ol>

<h3>Visualization of the Algorithm</h3>

<h4>Example 1: List with Odd Number of Nodes [1,2,3,4,5]</h4>

<div class="visualization">
    <table>
        <tr>
            <th>Iteration</th>
            <th>Linked List State</th>
            <th>Slow Pointer</th>
            <th>Fast Pointer</th>
        </tr>
        <tr>
            <td>Initial</td>
            <td>
                <div class="node">1<div class="slow-pointer">slow</div><div class="fast-pointer">fast</div></div>
                <div class="node-link">→</div>
                <div class="node">2</div>
                <div class="node-link">→</div>
                <div class="node">3</div>
                <div class="node-link">→</div>
                <div class="node">4</div>
                <div class="node-link">→</div>
                <div class="node">5</div>
            </td>
            <td>Node 1</td>
            <td>Node 1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>
                <div class="node">1</div>
                <div class="node-link">→</div>
                <div class="node">2<div class="slow-pointer">slow</div></div>
                <div class="node-link">→</div>
                <div class="node">3<div class="fast-pointer">fast</div></div>
                <div class="node-link">→</div>
                <div class="node">4</div>
                <div class="node-link">→</div>
                <div class="node">5</div>
            </td>
            <td>Node 2</td>
            <td>Node 3</td>
        </tr>
        <tr>
            <td>2</td>
            <td>
                <div class="node">1</div>
                <div class="node-link">→</div>
                <div class="node">2</div>
                <div class="node-link">→</div>
                <div class="node">3<div class="slow-pointer">slow</div></div>
                <div class="node-link">→</div>
                <div class="node">4</div>
                <div class="node-link">→</div>
                <div class="node">5<div class="fast-pointer">fast</div></div>
            </td>
            <td>Node 3</td>
            <td>Node 5</td>
        </tr>
        <tr>
            <td>3</td>
            <td>
                <div class="node">1</div>
                <div class="node-link">→</div>
                <div class="node">2</div>
                <div class="node-link">→</div>
                <div class="node highlighted">3<div class="slow-pointer">slow</div></div>
                <div class="node-link">→</div>
                <div class="node">4</div>
                <div class="node-link">→</div>
                <div class="node">5</div>
            </td>
            <td>Node 3</td>
            <td>null</td>
        </tr>
        <tr>
            <td>Result</td>
            <td colspan="3">Return Node 3 as the middle node</td>
        </tr>
    </table>
</div>

<h4>Example 2: List with Even Number of Nodes [1,2,3,4,5,6]</h4>

<div class="visualization">
    <table>
        <tr>
            <th>Iteration</th>
            <th>Linked List State</th>
            <th>Slow Pointer</th>
            <th>Fast Pointer</th>
        </tr>
        <tr>
            <td>Initial</td>
            <td>
                <div class="node">1<div class="slow-pointer">slow</div><div class="fast-pointer">fast</div></div>
                <div class="node-link">→</div>
                <div class="node">2</div>
                <div class="node-link">→</div>
                <div class="node">3</div>
                <div class="node-link">→</div>
                <div class="node">4</div>
                <div class="node-link">→</div>
                <div class="node">5</div>
                <div class="node-link">→</div>
                <div class="node">6</div>
            </td>
            <td>Node 1</td>
            <td>Node 1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>
                <div class="node">1</div>
                <div class="node-link">→</div>
                <div class="node">2<div class="slow-pointer">slow</div></div>
                <div class="node-link">→</div>
                <div class="node">3<div class="fast-pointer">fast</div></div>
                <div class="node-link">→</div>
                <div class="node">4</div>
                <div class="node-link">→</div>
                <div class="node">5</div>
                <div class="node-link">→</div>
                <div class="node">6</div>
            </td>
            <td>Node 2</td>
            <td>Node 3</td>
        </tr>
        <tr>
            <td>2</td>
            <td>
                <div class="node">1</div>
                <div class="node-link">→</div>
                <div class="node">2</div>
                <div class="node-link">→</div>
                <div class="node">3<div class="slow-pointer">slow</div></div>
                <div class="node-link">→</div>
                <div class="node">4</div>
                <div class="node-link">→</div>
                <div class="node">5<div class="fast-pointer">fast</div></div>
                <div class="node-link">→</div>
                <div class="node">6</div>
            </td>
            <td>Node 3</td>
            <td>Node 5</td>
        </tr>
        <tr>
            <td>3</td>
            <td>
                <div class="node">1</div>
                <div class="node-link">→</div>
                <div class="node">2</div>
                <div class="node-link">→</div>
                <div class="node">3</div>
                <div class="node-link">→</div>
                <div class="node highlighted">4<div class="slow-pointer">slow</div></div>
                <div class="node-link">→</div>
                <div class="node">5</div>
                <div class="node-link">→</div>
                <div class="node">6</div>
            </td>
            <td>Node 4</td>
            <td>null</td>
        </tr>
        <tr>
            <td>Result</td>
            <td colspan="3">Return Node 4 as the middle node</td>
        </tr>
    </table>
</div>

<h2>Python Implementation</h2>

<pre class="code-block">
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

def middleNode(head):
    slow = head
    if head.next is None:  # List has only one node
        return slow
        
    fast = head
    while fast and fast.next:  # While fast pointer hasn't reached the end
        slow = slow.next  # Move slow pointer one step
        fast = fast.next.next  # Move fast pointer two steps
    
    return slow  # Slow pointer is now at the middle node
</pre>

<h2>Time and Space Complexity</h2>

<h3>Time Complexity</h3>
<p><strong>O(n)</strong> where n is the number of nodes in the linked list. We only need to traverse through the list once. The fast pointer traverses twice as fast, but that's still O(n) time.</p>

<h3>Space Complexity</h3>
<p><strong>O(1)</strong> since we only use two pointers regardless of the size of the linked list.</p>

<h2>Edge Cases and Considerations</h2>

<ul>
    <li><strong>Single Node List:</strong> If the list has only one node, that node is the middle node.</li>
    <li><strong>Empty List:</strong> If the list is empty (head is null), the function would return null. However, the problem statement guarantees that there will be at least one node in the list.</li>
    <li><strong>Even vs Odd Length Lists:</strong> Our implementation handles both cases correctly:
        <ul>
            <li>For odd length lists, the slow pointer will land on the middle node.</li>
            <li>For even length lists, the slow pointer will land on the second middle node, which is what the problem asks for.</li>
        </ul>
    </li>
</ul>

<h2>Alternative Approaches</h2>

<h3>Two-Pass Approach</h3>
<p>Another way to solve this problem is to count the number of nodes in the linked list first, then traverse to the middle node:</p>

<pre class="code-block">
def middleNode(head):
    # First pass: count the number of nodes
    count = 0
    current = head
    while current:
        count += 1
        current = current.next
        
    # Find the middle index
    middle_index = count // 2
    
    # Second pass: traverse to the middle node
    current = head
    for i in range(middle_index):
        current = current.next
        
    return current
</pre>

<p>This approach has:</p>
<ul>
    <li>Time Complexity: O(n) because we traverse the list twice</li>
    <li>Space Complexity: O(1)</li>
</ul>

<p>While this approach also works, the Fast & Slow pointers approach is more elegant and requires only a single pass through the linked list.</p>

<h2>Summary</h2>

<p>The Middle of the Linked List problem is a perfect candidate for the Fast & Slow Pointers pattern. By moving one pointer at twice the speed of another, we can find the middle of the linked list in a single pass with O(1) space complexity.</p>

<p>This problem demonstrates one of the key applications of the Fast & Slow Pointers pattern: finding the middle element of a linked list. The same approach can be extended to other problems such as detecting cycles in a linked list, determining if a linked list is a palindrome, or finding the middle of an array.</p>

</body>
</html>
