<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unique Generalized Abbreviations Solution</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            color: #333;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border-radius: 8px;
        }
        .problem {
            background-color: #f0f8ff;
            border-left: 5px solid #4682b4;
        }
        .understanding {
            background-color: #f0fff0;
            border-left: 5px solid #2e8b57;
        }
        .approach {
            background-color: #fff0f5;
            border-left: 5px solid #db7093;
        }
        .implementation {
            background-color: #fff8dc;
            border-left: 5px solid #daa520;
        }
        .code {
            background-color: #f8f8ff;
            border-left: 5px solid #6a5acd;
        }
        pre {
            background-color: #1e1e1e;
            color: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }
        pre .comment {
            color: #6a9955;
            font-style: italic;
        }
        h2 {
            color: #444;
            border-bottom: 2px solid #ddd;
            padding-bottom: 5px;
        }
        .example {
            background-color: #f9f9f9;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            border-left: 3px solid #666;
        }
        .visualization {
            background-color: #f9f0ff;
            border-left: 5px solid #722ed1;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .abbr-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        .abbr-item {
            border: 1px solid #007bff;
            border-radius: 4px;
            padding: 5px 10px;
            background-color: #e7f5ff;
            font-family: monospace;
        }
        .highlight {
            background-color: #ffeb3b;
            padding: 0 2px;
        }
        .decision-tree {
            font-family: monospace;
            white-space: pre;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <h1>Unique Generalized Abbreviations</h1>

    <div class="section problem">
        <h2>Problem Statement</h2>
        <p>
            Given a word, write a function to generate all of its unique generalized abbreviations.
        </p>
        <p>
            A generalized abbreviation of a word can be generated by replacing each substring of the word with the count of characters in the substring.
        </p>

        <div class="example">
            <h3>Example 1:</h3>
            <pre>
Input: word = "ab"
Output: ["2", "1b", "a1", "ab"]

Explanation: "ab" has four substrings: "", "a", "b", and "ab". After replacing these substrings in the actual word by the count of characters, we get all the generalized abbreviations: "ab", "1b", "a1", and "2".</pre>
        </div>

        <div class="example">
            <h3>Example 2:</h3>
            <pre>
Input: word = "abc"
Output: ["3", "2c", "1b1", "1bc", "a2", "a1c", "ab1", "abc"]
</pre>
        </div>
    </div>

    <div class="section understanding">
        <h2>Understanding the Problem</h2>
        <p>
            This problem asks us to generate all possible ways to abbreviate a word by replacing substrings with the count of characters in those substrings. Let's break down the concept of generalized abbreviations:
        </p>
        <ul>
            <li>For each character in the word, we have two choices:
                <ol>
                    <li>Keep the character as is</li>
                    <li>Replace it with a count (which represents how many consecutive characters we're abbreviating)</li>
                </ol>
            </li>
            <li>We need to ensure that adjacent numbers are combined (e.g., we should have "2" instead of "11" for two consecutive abbreviated characters)</li>
        </ul>
        <p>
            Let's examine all abbreviations for the word "word":
        </p>
        <div class="abbr-container">
            <div class="abbr-item">word</div>
            <div class="abbr-item">wor1</div>
            <div class="abbr-item">wo1d</div>
            <div class="abbr-item">wo2</div>
            <div class="abbr-item">w1rd</div>
            <div class="abbr-item">w1r1</div>
            <div class="abbr-item">w2d</div>
            <div class="abbr-item">w3</div>
            <div class="abbr-item">1ord</div>
            <div class="abbr-item">1or1</div>
            <div class="abbr-item">1o1d</div>
            <div class="abbr-item">1o2</div>
            <div class="abbr-item">2rd</div>
            <div class="abbr-item">2r1</div>
            <div class="abbr-item">3d</div>
            <div class="abbr-item">4</div>
        </div>
        <p>
            There are 2<sup>n</sup> possible abbreviations for a word with n characters, because for each character, we have two choices (keep or abbreviate).
        </p>
    </div>

    <div class="section approach">
        <h2>Approach: Backtracking</h2>
        <p>
            We can solve this problem using a backtracking approach. At each step, we have two choices for each character:
        </p>
        <ol>
            <li>Abbreviate it: Increment our count of abbreviated characters</li>
            <li>Keep it as is: Add the current count (if any) followed by the current character to our result</li>
        </ol>
        <p>
            The key insight is to keep track of a running count of abbreviated characters, and only add this count to our abbreviation when we decide to keep a character or when we reach the end of the word.
        </p>

        <div class="visualization">
            <h3>Visualization of the Backtracking Approach</h3>
            <p>Let's trace through the process for the word "abc":</p>
            <pre class="decision-tree">
Start with empty result "", index = 0, count = 0

For each character, we have two choices: abbreviate it or keep it.

1. Character 'a' (index 0):
   a. Abbreviate 'a': "", index = 1, count = 1
      i. Character 'b' (index 1):
         - Abbreviate 'b': "", index = 2, count = 2
            * Character 'c' (index 2):
              > Abbreviate 'c': "", index = 3, count = 3
                End of word: Add count to result -> "3"
              > Keep 'c': "2c", index = 3, count = 0
                End of word: Add to result -> "2c"
         - Keep 'b': "1b", index = 2, count = 0
            * Character 'c' (index 2):
              > Abbreviate 'c': "1b", index = 3, count = 1
                End of word: Add count to result -> "1b1"
              > Keep 'c': "1bc", index = 3, count = 0
                End of word: Add to result -> "1bc"
   b. Keep 'a': "a", index = 1, count = 0
      i. Character 'b' (index 1):
         - Abbreviate 'b': "a", index = 2, count = 1
            * Character 'c' (index 2):
              > Abbreviate 'c': "a", index = 3, count = 2
                End of word: Add count to result -> "a2"
              > Keep 'c': "a1c", index = 3, count = 0
                End of word: Add to result -> "a1c"
         - Keep 'b': "ab", index = 2, count = 0
            * Character 'c' (index 2):
              > Abbreviate 'c': "ab", index = 3, count = 1
                End of word: Add count to result -> "ab1"
              > Keep 'c': "abc", index = 3, count = 0
                End of word: Add to result -> "abc"

Final result: ["3", "2c", "1b1", "1bc", "a2", "a1c", "ab1", "abc"]</pre>
        </div>
    </div>

    <div class="section implementation">
        <h2>Implementation</h2>
        <p>
            Here's the Python implementation of our backtracking approach:
        </p>

        <pre>
def generateAbbreviations(word):
    <span class="comment">"""Generate all unique generalized abbreviations of the word.
    
    Args:
        word: Input string
        
    Returns:
        List of all possible generalized abbreviations
    """</span>
    result = []
    backtrack(word, result, 0, 0, "")
    return result

def backtrack(word, result, index, count, current):
    <span class="comment">"""Recursive backtracking function to generate abbreviations.
    
    Args:
        word: Input string
        result: List to store all abbreviations
        index: Current character index
        count: Count of consecutive abbreviated characters
        current: Current abbreviation being built
    """</span>
    # Base case: reached the end of the word
    if index == len(word):
        # Add any remaining count to the current abbreviation
        if count > 0:
            current += str(count)
        result.append(current)
        return
    
    # Option 1: Abbreviate the current character (skip it and increment count)
    backtrack(word, result, index + 1, count + 1, current)
    
    # Option 2: Keep the current character
    # First, add the count of abbreviated characters (if any)
    new_current = current
    if count > 0:
        new_current += str(count)
    # Then add the current character
    new_current += word[index]
    # Continue with the next character (reset count to 0)
    backtrack(word, result, index + 1, 0, new_current)</pre>

        <h3>Time and Space Complexity</h3>
        <p>
            <strong>Time Complexity:</strong> O(n * 2<sup>n</sup>), where n is the length of the input word.
            <ul>
                <li>There are 2<sup>n</sup> possible abbreviations (for each character, we have two choices: keep or abbreviate).</li>
                <li>For each abbreviation, we perform O(n) work to build and add it to the result.</li>
            </ul>
        </p>
        <p>
            <strong>Space Complexity:</strong> O(n * 2<sup>n</sup>)
            <ul>
                <li>O(2<sup>n</sup>) space for storing all abbreviations.</li>
                <li>Each abbreviation requires O(n) space in the worst case.</li>
                <li>Additionally, O(n) space is used for the recursion stack.</li>
            </ul>
        </p>
    </div>

    <div class="section code">
        <h2>Alternative Implementation</h2>
        <p>
            Here's a more concise implementation that achieves the same result with slightly different parameter handling:
        </p>

        <pre>
def generateAbbreviations(word):
    <span class="comment">"""Generate all unique generalized abbreviations of the word."""
</span>    result = []
    helper(word, result, 0, 0, "")
    return result

def helper(word, result, index, count, current):
    <span class="comment">"""Helper function with cleaner parameter handling."""
</span>    if index == len(word):
        # Add any remaining count to the result
        if count > 0:
            current += str(count)
        result.append(current)
    else:
        # Option 1: Abbreviate the current character
        helper(word, result, index + 1, count + 1, current)
        
        # Option 2: Keep the current character
        # Add count if necessary, then add the current character
        suffix = str(count) if count > 0 else ""
        helper(word, result, index + 1, 0, current + suffix + word[index])</pre>

        <p>
            This version is more elegant as it handles the addition of the count and the current character in a more streamlined way for the second option.
        </p>
    </div>

    <div class="section approach">
        <h2>Testing the Solution</h2>
        <p>
            Let's test our implementation with a few examples:
        </p>

        <div class="example">
            <pre>
# Example 1
generateAbbreviations("ab")
# Output: ["2", "1b", "a1", "ab"]

# Example 2
generateAbbreviations("abc")
# Output: ["3", "2c", "1b1", "1bc", "a2", "a1c", "ab1", "abc"]

# Example 3
generateAbbreviations("word")
# Output: ["4", "3d", "2r1", "2rd", "1o2", "1o1d", "1or1", "1ord", "w3", "w2d", "w1r1", "w1rd", "wo2", "wo1d", "wor1", "word"]</pre>
        </div>

        <p>
            Our solution correctly generates all unique generalized abbreviations for these examples.
        </p>
        <p>
            Let's verify the count of abbreviations for different word lengths:
        </p>
        <table>
            <tr>
                <th>Word Length</th>
                <th>Number of Abbreviations</th>
                <th>Formula</th>
            </tr>
            <tr>
                <td>1</td>
                <td>2</td>
                <td>2<sup>1</sup> = 2</td>
            </tr>
            <tr>
                <td>2</td>
                <td>4</td>
                <td>2<sup>2</sup> = 4</td>
            </tr>
            <tr>
                <td>3</td>
                <td>8</td>
                <td>2<sup>3</sup> = 8</td>
            </tr>
            <tr>
                <td>4</td>
                <td>16</td>
                <td>2<sup>4</sup> = 16</td>
            </tr>
        </table>
        <p>
            This confirms our understanding that there are 2<sup>n</sup> possible abbreviations for a word of length n.
        </p>
    </div>

    <div class="section understanding">
        <h2>Variations and Applications</h2>
        <p>
            Generalized abbreviations have several practical applications:
        </p>
        <ul>
            <li><strong>Text Compression:</strong> Abbreviations can be used to compress text, especially in scenarios where space is limited.</li>
            <li><strong>Text Messaging:</strong> Abbreviated forms of words are commonly used in text messaging to type faster.</li>
            <li><strong>Word Games:</strong> Games like Scrabble or Word Jumble can use abbreviated forms as valid plays.</li>
            <li><strong>Information Retrieval:</strong> Search systems may need to handle abbreviated forms of words to improve search results.</li>
        </ul>
        <p>
            The algorithm for generating generalized abbreviations can be extended or modified for various purposes:
        </p>
        <ul>
            <li><strong>Limited Abbreviation Length:</strong> Generate only abbreviations where at most k characters are abbreviated.</li>
            <li><strong>Pattern-Based Abbreviation:</strong> Generate abbreviations that follow specific patterns or rules.</li>
            <li><strong>Dictionary-Based Abbreviation:</strong> Generate only abbreviations that match entries in a given dictionary.</li>
        </ul>
    </div>

    <div class="section understanding">
        <h2>Related Problems</h2>
        <p>
            If you've mastered this problem, you might want to try these related backtracking problems:
        </p>
        <ul>
            <li><strong>Generate Parentheses:</strong> Generate all combinations of well-formed parentheses.</li>
            <li><strong>Permutations:</strong> Generate all permutations of a given array.</li>
            <li><strong>Subsets:</strong> Generate all possible subsets of a given set.</li>
            <li><strong>Combinations:</strong> Generate all possible combinations of k numbers out of 1...n.</li>
            <li><strong>Word Break:</strong> Determine if a string can be segmented into words from a dictionary.</li>
        </ul>
        <p>
            These problems all involve generating different combinations or permutations and can be approached using similar backtracking techniques.
        </p>
    </div>
</body>
</html>
