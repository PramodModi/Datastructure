<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number of Longest Increasing Subsequence</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #fff;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            padding-left: 20px;
            padding-right: 20px;
        }
        h1 {
            color: #444;
            padding: 20px;
            margin: 0;
            font-size: 24px;
            font-weight: bold;
        }
        /* Problem Statement Section */
        .problem-statement {
            background-color: #f5f9fc;
            padding: 20px;
            border-left: 4px solid #4a90e2;
            margin-bottom: 20px;
            position: relative;
        }
        .problem-statement h2 {
            color: #444;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        .problem-statement p {
            margin-bottom: 15px;
        }
        
        /* Example Section */
        .example {
            margin: 15px 0;
            padding-left: 20px;
            border-left: 2px solid #666;
        }
        .example h3 {
            margin-bottom: 10px;
            color: #333;
        }
        .code-block {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            margin: 10px 0;
        }
        
        /* Constraints Section */
        .constraints {
            margin-top: 15px;
        }
        .constraints h3 {
            color: #333;
            margin-bottom: 10px;
        }
        .constraints ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }
        
        /* Understanding Section */
        .understanding {
            background-color: #f0f7fa;
            padding: 20px;
            border-left: 4px solid #27ae60;
            margin-bottom: 20px;
        }
        .understanding h2 {
            color: #27ae60;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Approach Section */
        .approach {
            background-color: #f9f5fc;
            padding: 20px;
            border-left: 4px solid #9b59b6;
            margin-bottom: 20px;
        }
        .approach h2 {
            color: #9b59b6;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Visualization Section */
        .visualization {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-left: 4px solid #e74c3c;
            margin: 15px 0;
        }
        .visualization h3 {
            color: #ff6b6b;
            margin-top: 0;
            padding-bottom: 10px;
        }
        .visualization pre {
            background-color: #2d2d2d;
            border: 1px solid #555;
            color: #ddd;
        }
        
        /* Implementation Section */
        .implementation {
            background-color: #f5fcf5;
            padding: 20px;
            border-left: 4px solid #16a085;
            margin-bottom: 20px;
        }
        .implementation h2 {
            color: #16a085;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Complexity Section */
        .complexity {
            background-color: #fafafa;
            padding: 15px;
            border-left: 4px solid #95a5a6;
            margin: 15px 0;
        }
        .complexity h3 {
            color: #7f8c8d;
            margin-top: 0;
        }
        
        /* Alternative Implementation Section */
        .alternative {
            background-color: #fcfcf5;
            padding: 15px;
            border-left: 4px solid #f39c12;
            margin: 15px 0;
        }
        .alternative h3 {
            color: #f39c12;
            margin-top: 0;
        }
        
        pre {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #444;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            color: white;
        }
        
        /* General Section */
        .section {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>Number of Longest Increasing Subsequence</h1>
    
    <!-- Problem Statement Section -->
    <div class="problem-statement">
        <h2>Problem Statement</h2>
        <p>Given an integer array nums, return the number of longest increasing subsequences.</p>
        <p>Notice that the sequence has to be strictly increasing.</p>
        
        <div class="example">
            <h3>Example 1:</h3>
            <div class="code-block">
                <div>Input: nums = [1,3,5,4,7]</div>
                <div>Output: 2</div>
                <div>Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].</div>
            </div>
        </div>
        
        <div class="example">
            <h3>Example 2:</h3>
            <div class="code-block">
                <div>Input: nums = [2,2,2,2,2]</div>
                <div>Output: 5</div>
                <div>Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.</div>
            </div>
        </div>
        
        <div class="constraints">
            <h3>Constraints:</h3>
            <ul>
                <li>1 <= nums.length <= 2000</li>
                <li>-10<sup>6</sup> <= nums[i] <= 10<sup>6</sup></li>
            </ul>
        </div>
    </div>
    
    <!-- Understanding Section -->
    <div class="understanding">
        <h2>Understanding the Problem</h2>
        <p>This problem is an extension of the classic Longest Increasing Subsequence (LIS) problem. Instead of just finding the length of the LIS or a single LIS, we need to count how many different subsequences achieve the maximum length.</p>
        <p>Key points to understand:</p>
        <ul>
            <li>A subsequence doesn't have to be contiguous (elements can be skipped)</li>
            <li>The subsequence must be strictly increasing (each element must be greater than the previous one)</li>
            <li>We need to count all distinct subsequences that have the maximum length</li>
        </ul>
        
        <p>For example, in [1,3,5,4,7], there are two different ways to form a subsequence of length 4:</p>
        <ul>
            <li>[1,3,5,7]</li>
            <li>[1,3,4,7]</li>
        </ul>
        <p>Both have length 4, which is the maximum possible length, so the answer is 2.</p>
        
        <p>For additional understanding, refer to this video explanation: <a href="https://www.youtube.com/watch?v=G2yXxQed_Yg" target="_blank">https://www.youtube.com/watch?v=G2yXxQed_Yg</a></p>
    </div>
    
    <!-- Approach Section -->
    <div class="approach">
        <h2>Approach</h2>
        <p>This problem requires us to extend the standard LIS algorithm to also count the number of sequences with the maximum length.</p>
        
        <p>To solve this problem, we'll use a binary search-based approach with additional tracking of counts:</p>
        <ul>
            <li>Maintain a list of lists where each inner list stores (number, count) pairs</li>
            <li>Each list in the structure represents all possible endings for subsequences of a specific length</li>
            <li>For each number in the input array, we need to determine:</li>
            <ul>
                <li>If it can extend the current longest subsequence</li>
                <li>If it can form new sequences of existing lengths</li>
                <li>How many new sequences it contributes</li>
            </ul>
        </ul>
        
        <div class="visualization">
            <h3>Visualization</h3>
            <p>Let's trace the algorithm for the example [1,3,5,4,7]:</p>
            <pre>
Start with empty sub_list
- Process 1: sub_list = [[(1, 1)]]  (one subsequence of length 1)
- Process 3: sub_list = [[(1, 1)], [(3, 1)]]  (one subsequence of length 2)
- Process 5: sub_list = [[(1, 1)], [(3, 1)], [(5, 1)]]  (one subsequence of length 3)
- Process 4: sub_list = [[(1, 1)], [(3, 1)], [(4, 1), (5, 1)]]  (two subsequences of length 3)
- Process 7: sub_list = [[(1, 1)], [(3, 1)], [(4, 1), (5, 1)], [(7, 2)]]  (two subsequences of length 4)

The final count is 2 (from the last element of the last list).
            </pre>
        </div>
    </div>
    
    <!-- Implementation Section -->
    <div class="implementation">
        <h2>Implementation</h2>
        
        <pre><code>def findNumberOfLIS(nums):
        sub_list= []
        for n in nums:
            if len(sub_list) == 0:
                sub_list.append([(n, 1)])
            elif sub_list[-1][-1][0] < n:
                lastArray = [x[0] for x in sub_list[-1]]
                pos = findSmaller(lastArray, n) # get the index of greatest number < n
                count = sub_list[-1][-1][1] - sub_list[-1][pos-1][1] if pos > 0 else sub_list[-1][-1][1]
                sub_list.append([(n, count)])
            else:
                sub_array = [array[-1][0] for array in sub_list]
                idx = findIndex(sub_array, n) # find the index of array, having smallest number > n
                count  = 1
                if idx > 0:
                    # get the position of n in previous array (array at idx-1)
                    lastArray = [x[0] for x in sub_list[idx-1]]
                    pos = findSmaller(lastArray, n) # get the index of greatest number < n
                    count = sub_list[idx-1][-1][1] - sub_list[idx-1][pos-1][1] if pos > 0 else sub_list[idx-1][-1][-1]
                sub_list[idx].append((n, count + sub_list[idx][-1][1] if len(sub_list[idx])>0 else count))  
           
        return sub_list[-1][-1][1]

def findSmaller(array, n):
    startIndex = 0
    endIndex = len(array)-1
    while startIndex < endIndex:
        mid = startIndex + (endIndex-startIndex)//2
        if array[mid] < n:
            endIndex = mid
        else:
            startIndex = mid+1
    return startIndex

def findIndex(array, n):
    startIndex = 0
    endIndex = len(array)-1
    while startIndex < endIndex:
        mid = startIndex + (endIndex-startIndex)//2
        if array[mid] >= n:
            endIndex = mid
        else:
            startIndex = mid+1
    return startIndex</code></pre>
        
        <div class="complexity">
            <h3>Time Complexity Analysis</h3>
            <p><strong>Time Complexity:</strong> O(n log n)</p>
            <ul>
                <li>We iterate through the array once, which is O(n)</li>
                <li>For each element, we perform binary searches which are O(log n)</li>
                <li>Therefore, the overall time complexity is O(n log n)</li>
            </ul>
            
            <p><strong>Space Complexity:</strong> O(n)</p>
            <ul>
                <li>We use the sub_list structure which, in the worst case, could store information for all elements</li>
                <li>Therefore, the space complexity is O(n)</li>
            </ul>
        </div>
    </div>
    
    <!-- Testing Section -->
    <div class="implementation">
        <h2>Testing</h2>
        <div class="code-block">
            <div># Test Case 1</div>
            <div>nums = [1,3,5,4,7]</div>
            <div>findNumberOfLIS(nums)  # Output: 2</div>
            <div></div>
            <div># Test Case 2</div>
            <div>nums = [10,9,2,5,3,7,101,18]</div>
            <div>findNumberOfLIS(nums)  # Output: 4</div>
            <div></div>
            <div># Test Case 3</div>
            <div>nums = [10,9,1,11,5,3,2,7,101,18]</div>
            <div>findNumberOfLIS(nums)  # Output: 6</div>
            <div></div>
            <div># Test Case 4</div>
            <div>nums = [10,9,1,11,5]</div>
            <div>findNumberOfLIS(nums)  # Output: 4</div>
        </div>
    </div>
    
    <!-- Related Problems Section -->
    <div class="approach">
        <h2>Related Problems</h2>
        <ul>
            <li><a href="Longest_Increasing_Subsequence_v2.html">Longest Increasing Subsequence</a> - Finding the length of the longest increasing subsequence</li>
            <li><a href="Longest_Continuous_Increasing_Subsequence_v2.html">Longest Continuous Increasing Subsequence</a> - Finding the longest subarray with strictly increasing elements</li>
            <li><a href="LongestIncreasingSubsequence_ReturnSubSeq_v2.html">Longest Increasing Subsequence - Return Subsequence</a> - Return the actual subsequence rather than just the length</li>
            <li><a href="https://leetcode.com/problems/delete-and-earn/">Delete and Earn</a> - A dynamic programming problem with a similar structure</li>
            <li><a href="https://leetcode.com/problems/wiggle-subsequence/">Wiggle Subsequence</a> - Finding the length of the longest wiggle subsequence</li>
        </ul>
    </div>
</body>
</html>
