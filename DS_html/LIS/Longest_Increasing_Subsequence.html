<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Longest Increasing Subsequence</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #fff;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            padding-left: 20px;
            padding-right: 20px;
        }
        h1 {
            color: #444;
            padding: 20px;
            margin: 0;
            font-size: 24px;
            font-weight: bold;
        }
        /* Problem Statement Section */
        .problem-statement {
            background-color: #f5f9fc;
            padding: 20px;
            border-left: 4px solid #4a90e2;
            margin-bottom: 20px;
            position: relative;
        }
        .problem-statement h2 {
            color: #444;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        .problem-statement p {
            margin-bottom: 15px;
        }
        
        /* Example Section */
        .example {
            margin: 15px 0;
            padding-left: 20px;
            border-left: 2px solid #666;
        }
        .example h3 {
            margin-bottom: 10px;
            color: #333;
        }
        .code-block {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            margin: 10px 0;
        }
        
        /* Constraints Section */
        .constraints {
            margin-top: 15px;
        }
        .constraints h3 {
            color: #333;
            margin-bottom: 10px;
        }
        .constraints ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }
        
        /* Understanding Section */
        .understanding {
            background-color: #f0f7fa;
            padding: 20px;
            border-left: 4px solid #27ae60;
            margin-bottom: 20px;
        }
        .understanding h2 {
            color: #27ae60;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Approach Section */
        .approach {
            background-color: #f9f5fc;
            padding: 20px;
            border-left: 4px solid #9b59b6;
            margin-bottom: 20px;
        }
        .approach h2 {
            color: #9b59b6;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Visualization Section */
        .visualization {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-left: 4px solid #e74c3c;
            margin: 15px 0;
        }
        .visualization h3 {
            color: #ff6b6b;
            margin-top: 0;
            padding-bottom: 10px;
        }
        .visualization pre {
            background-color: #2d2d2d;
            border: 1px solid #555;
            color: #ddd;
        }
        
        /* Implementation Section */
        .implementation {
            background-color: #f5fcf5;
            padding: 20px;
            border-left: 4px solid #16a085;
            margin-bottom: 20px;
        }
        .implementation h2 {
            color: #16a085;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Complexity Section */
        .complexity {
            background-color: #fafafa;
            padding: 15px;
            border-left: 4px solid #95a5a6;
            margin: 15px 0;
        }
        .complexity h3 {
            color: #7f8c8d;
            margin-top: 0;
        }
        
        /* Alternative Implementation Section */
        .alternative {
            background-color: #fcfcf5;
            padding: 15px;
            border-left: 4px solid #f39c12;
            margin: 15px 0;
        }
        .alternative h3 {
            color: #f39c12;
            margin-top: 0;
        }
        
        pre {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #444;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            color: white;
        }
        
        /* General Section */
        .section {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>Longest Increasing Subsequence</h1>
    
    <!-- Problem Statement Section -->
    <div class="problem-statement">
        <h2>Problem Statement</h2>
        <p>Given an integer array nums, return the length of the longest strictly increasing subsequence.</p>
        <p>A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].</p>
        
        <div class="example">
            <h3>Example 1:</h3>
            <div class="code-block">
                <div>Input: nums = [10,9,2,5,3,7,101,18]</div>
                <div>Output: 4</div>
                <div>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</div>
            </div>
        </div>
        
        <div class="example">
            <h3>Example 2:</h3>
            <div class="code-block">
                <div>Input: nums = [0,1,0,3,2,3]</div>
                <div>Output: 4</div>
            </div>
        </div>
        
        <div class="example">
            <h3>Example 3:</h3>
            <div class="code-block">
                <div>Input: nums = [7,7,7,7,7,7,7]</div>
                <div>Output: 1</div>
            </div>
        </div>
        
        <div class="constraints">
            <h3>Constraints:</h3>
            <ul>
                <li>1 <= nums.length <= 2500</li>
                <li>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></li>
            </ul>
            <p><strong>Follow up:</strong> Can you come up with an algorithm that runs in O(n log(n)) time complexity?</p>
        </div>
    </div>
    
    <!-- Understanding Section -->
    <div class="understanding">
        <h2>Understanding the Problem</h2>
        <p>This problem asks us to find the length of the longest subsequence in which all elements are in strictly increasing order.</p>
        <p>Key points to understand:</p>
        <ul>
            <li>A subsequence doesn't have to be contiguous (elements can be skipped)</li>
            <li>The subsequence must be strictly increasing (each element must be greater than the previous one)</li>
            <li>We only need to return the length of the longest such subsequence, not the subsequence itself</li>
        </ul>
        
        <p>For example, in [10,9,2,5,3,7,101,18], we can form several increasing subsequences:</p>
        <ul>
            <li>[2,5,7,101]</li>
            <li>[2,3,7,101]</li>
            <li>[2,3,7,18]</li>
            <li>[2,5,7,18]</li>
        </ul>
        <p>All of these have length 4, which is the maximum possible for this array.</p>
        
        <p>For additional understanding, refer to this video explanation: <a href="https://www.youtube.com/watch?v=W8DMcy8L5CI" target="_blank">https://www.youtube.com/watch?v=W8DMcy8L5CI</a></p>
    </div>
    
    <!-- Approach Section -->
    <div class="approach">
        <h2>Approach</h2>
        <p>There are multiple approaches to solve this problem:</p>
        
        <h3>1. Brute Force Approach</h3>
        <p>Generate all possible subsequences and find the longest increasing one. This would be exponential in time complexity and is not practical for large inputs.</p>
        
        <h3>2. Dynamic Programming Approach - O(n²)</h3>
        <p>We can use dynamic programming to solve this more efficiently:</p>
        <ul>
            <li>Create a DP array where dp[i] represents the length of the longest increasing subsequence ending at index i</li>
            <li>For each element at index i, we check all previous elements j from 0 to i-1</li>
            <li>If nums[i] > nums[j], we can extend the subsequence ending at j, so dp[i] = max(dp[i], dp[j] + 1)</li>
            <li>The final answer is the maximum value in the dp array</li>
        </ul>
        
        <h3>3. Binary Search Approach - O(n log n)</h3>
        <p>An even more efficient approach uses binary search:</p>
        <ul>
            <li>Maintain an array `sub` where sub[i] represents the smallest ending number of an increasing subsequence of length i+1</li>
            <li>For each number in the input, find its position in the `sub` array using binary search</li>
            <li>Replace the element at that position or append if it's greater than all elements</li>
            <li>The length of the `sub` array at the end represents the length of the LIS</li>
        </ul>
        
        <div class="visualization">
            <h3>Visualization of the Binary Search Approach</h3>
            <p>Let's visualize how the algorithm works with example [10,9,2,5,3,7,101,18]:</p>
            <pre>
Initial sub = []
- Process 10: sub = [10]
- Process 9: sub = [9] (replace 10 with 9, as both form LIS of length 1)
- Process 2: sub = [2] (replace 9 with 2, as both form LIS of length 1)
- Process 5: sub = [2,5] (append 5, as it forms LIS of length 2)
- Process 3: sub = [2,3] (replace 5 with 3, as 3 < 5 and both form LIS of length 2)
- Process 7: sub = [2,3,7] (append 7, as it forms LIS of length 3)
- Process 101: sub = [2,3,7,101] (append 101, as it forms LIS of length 4)
- Process 18: sub = [2,3,7,18] (replace 101 with 18, as 18 < 101 and both form LIS of length 4)
            </pre>
            <p>Final length = 4</p>
            <p>Note: The `sub` array doesn't necessarily represent an actual subsequence of the input, but its length gives us the length of the LIS.</p>
        </div>
    </div>
    
    <!-- Implementation Section -->
    <div class="implementation">
        <h2>Implementation</h2>
        
        <h3>Approach 1: Binary Search - O(n log n)</h3>
        <pre><code>## O(nLogn)
## By using Binary Search
def lengthOfLIS(nums):
    sub = []
    for n in nums:
        if len(sub) == 0 or sub[-1] < n:
            sub.append(n)
        else:
            idx = binarySearch(sub, n) # get the index of smallest number greater than n in sub
            if sub[idx] < n:
                sub[idx + 1] = n
            else:
                sub[idx] = n
 
    return len(sub)

def binarySearch(array, n):
    startIdx = 0
    endIdx = len(array)-1
    
    while startIdx < endIdx:
        mid = (startIdx+endIdx)//2
        if array[mid] < n:
            startIdx = mid+1
        elif array[mid]> n:
            endIdx = mid-1
        else:
            startIdx = mid
            break
    return startIdx</code></pre>
        
        <div class="complexity">
            <h3>Time Complexity Analysis</h3>
            <p><strong>Time Complexity:</strong> O(n log n)</p>
            <ul>
                <li>We iterate through the array once, which is O(n)</li>
                <li>For each element, we might perform a binary search which is O(log n)</li>
                <li>Therefore, the overall time complexity is O(n log n)</li>
            </ul>
            
            <p><strong>Space Complexity:</strong> O(n)</p>
            <ul>
                <li>We use the `sub` array to keep track of the smallest ending elements</li>
                <li>In the worst case, the length of the LIS could be n (if the array is already sorted)</li>
                <li>Therefore, the space complexity is O(n)</li>
            </ul>
        </div>
        
        <div class="alternative">
            <h3>Alternative Implementation: Dynamic Programming - O(n²)</h3>
            <pre><code>## O(n^2)
## By using Back tracking
class Info:
    def __init__(self, maxlen):
        self.maxLen = maxlen
        self.result = []
def lengthOfLIS1(nums):
    info = Info(0)
    getLSISeq(nums, info, [], 0)
    return len(info.result)

def getLSISeq(nums, info, temp, index):
    
    if info.maxLen < len(temp):
        info.maxLen = len(temp)
        info.result = temp[:]
    
    if index == len(nums):
        return
    
    for i in range(index, len(nums)):
        if temp and temp[-1] >= nums[i]:
            continue
        temp.append(nums[i])
        getLSISeq(nums, info, temp, i+1)
        temp.pop()</code></pre>
            
            <p><strong>Time Complexity:</strong> O(2<sup>n</sup>) - Exponential</p>
            <p>This backtracking approach explores all possible subsequences, which leads to an exponential time complexity. While the approach works correctly, it's not efficient for large input arrays.</p>
            
            <p><strong>Space Complexity:</strong> O(n) for the recursion stack and to store the subsequence.</p>
        </div>
    </div>
    
    <!-- Testing Section -->
    <div class="implementation">
        <h2>Testing</h2>
        <div class="code-block">
            <div>nums = [10,9,2,5,3,7,101,18]</div>
            <div>lengthOfLIS(nums)  # Output: 4</div>
            <div></div>
            <div>nums = [10,9,2,5,3,7,101,18]</div>
            <div>lengthOfLIS1(nums)  # Output: 4</div>
        </div>
    </div>
    
    <!-- Related Problems Section -->
    <div class="approach">
        <h2>Related Problems</h2>
        <ul>
            <li><a href="Longest_Continuous_Increasing_Subsequence_v2.html">Longest Continuous Increasing Subsequence</a> - Finding the longest subarray with strictly increasing elements</li>
            <li><a href="LongestIncreasingSubsequence_ReturnSubSeq_v2.html">Longest Increasing Subsequence - Return Subsequence</a> - Return the actual subsequence rather than just the length</li>
            <li><a href="Number_of_Longest_Increasing_Subsequence_v2.html">Number of Longest Increasing Subsequence</a> - Count how many different longest increasing subsequences exist</li>
            <li><a href="https://leetcode.com/problems/russian-doll-envelopes/">Russian Doll Envelopes</a> - A 2D version of the LIS problem</li>
            <li><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/">Maximum Length of Pair Chain</a> - Another variation of LIS</li>
        </ul>
    </div>
</body>
</html>
