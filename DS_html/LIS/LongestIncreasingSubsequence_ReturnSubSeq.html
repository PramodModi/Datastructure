<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Longest Increasing Subsequence - Return Subsequence</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #fff;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            padding-left: 20px;
            padding-right: 20px;
        }
        h1 {
            color: #444;
            padding: 20px;
            margin: 0;
            font-size: 24px;
            font-weight: bold;
        }
        /* Problem Statement Section */
        .problem-statement {
            background-color: #f5f9fc;
            padding: 20px;
            border-left: 4px solid #4a90e2;
            margin-bottom: 20px;
            position: relative;
        }
        .problem-statement h2 {
            color: #444;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        .problem-statement p {
            margin-bottom: 15px;
        }
        
        /* Example Section */
        .example {
            margin: 15px 0;
            padding-left: 20px;
            border-left: 2px solid #666;
        }
        .example h3 {
            margin-bottom: 10px;
            color: #333;
        }
        .code-block {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
            margin: 10px 0;
        }
        
        /* Constraints Section */
        .constraints {
            margin-top: 15px;
        }
        .constraints h3 {
            color: #333;
            margin-bottom: 10px;
        }
        .constraints ul {
            padding-left: 20px;
            margin-bottom: 15px;
        }
        
        /* Understanding Section */
        .understanding {
            background-color: #f0f7fa;
            padding: 20px;
            border-left: 4px solid #27ae60;
            margin-bottom: 20px;
        }
        .understanding h2 {
            color: #27ae60;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Approach Section */
        .approach {
            background-color: #f9f5fc;
            padding: 20px;
            border-left: 4px solid #9b59b6;
            margin-bottom: 20px;
        }
        .approach h2 {
            color: #9b59b6;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Visualization Section */
        .visualization {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-left: 4px solid #e74c3c;
            margin: 15px 0;
        }
        .visualization h3 {
            color: #ff6b6b;
            margin-top: 0;
            padding-bottom: 10px;
        }
        .visualization pre {
            background-color: #2d2d2d;
            border: 1px solid #555;
            color: #ddd;
        }
        
        /* Implementation Section */
        .implementation {
            background-color: #f5fcf5;
            padding: 20px;
            border-left: 4px solid #16a085;
            margin-bottom: 20px;
        }
        .implementation h2 {
            color: #16a085;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #ddd;
        }
        
        /* Complexity Section */
        .complexity {
            background-color: #fafafa;
            padding: 15px;
            border-left: 4px solid #95a5a6;
            margin: 15px 0;
        }
        .complexity h3 {
            color: #7f8c8d;
            margin-top: 0;
        }
        
        /* Alternative Implementation Section */
        .alternative {
            background-color: #fcfcf5;
            padding: 15px;
            border-left: 4px solid #f39c12;
            margin: 15px 0;
        }
        .alternative h3 {
            color: #f39c12;
            margin-top: 0;
        }
        
        pre {
            background-color: #1e1e1e;
            color: white;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #444;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            color: white;
        }
        
        /* General Section */
        .section {
            margin-bottom: 30px;
        }
    </style>
</head>
<body>
    <h1>Longest Increasing Subsequence - Return Subsequence</h1>
    
    <!-- Problem Statement Section -->
    <div class="problem-statement">
        <h2>Problem Statement</h2>
        <p>Given a non-empty array of integers, write a function that returns the longest strictly-increasing subsequence in the array.</p>
        <p>A subsequence of an array is a set of numbers that aren't necessarily adjacent in the array but that are in the same order as they appear in the array. For instance, the numbers [1, 3, 4] form a subsequence of the array [1, 2, 3, 4], and so do the numbers [2, 4]. Note that a single number in an array and the array itself are both valid subsequences of the array.</p>
        <p>You can assume that there will only be one longest increasing subsequence.</p>
        
        <div class="example">
            <h3>Example:</h3>
            <div class="code-block">
                <div>Input: array = [5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]</div>
                <div>Output: [-24, 2, 3, 5, 6, 35]</div>
            </div>
        </div>
    </div>
    
    <!-- Understanding Section -->
    <div class="understanding">
        <h2>Understanding the Problem</h2>
        <p>This problem is an extension of the classic Longest Increasing Subsequence (LIS) problem. Instead of just returning the length of the LIS, we need to return the actual subsequence elements.</p>
        <p>Key points to understand:</p>
        <ul>
            <li>A subsequence doesn't have to be contiguous (elements can be skipped)</li>
            <li>The subsequence must be strictly increasing (each element must be greater than the previous one)</li>
            <li>We need to return the actual subsequence, not just its length</li>
            <li>There is only one longest increasing subsequence (no need to handle multiple subsequences of the same length)</li>
        </ul>
        
        <p>For example, in [5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35], the longest increasing subsequence is [-24, 2, 3, 5, 6, 35], which has length 6.</p>
    </div>
    
    <!-- Approach Section -->
    <div class="approach">
        <h2>Approach</h2>
        <p>There are two main approaches to solve this problem:</p>
        
        <h3>1. Backtracking Approach - O(n²)</h3>
        <p>This approach uses recursion with backtracking to explore all possible increasing subsequences:</p>
        <ul>
            <li>Define a helper class to keep track of the maximum length and the corresponding subsequence</li>
            <li>Try each element as a potential part of the LIS</li>
            <li>For each element, we either include it in our current subsequence (if it maintains the increasing property) or skip it</li>
            <li>Keep track of the longest subsequence found so far</li>
        </ul>
        
        <h3>2. Dynamic Programming with Binary Search - O(n log n)</h3>
        <p>This more efficient approach uses binary search and additional bookkeeping to reconstruct the subsequence:</p>
        <ul>
            <li>Maintain arrays to track subsequence information</li>
            <li>Use binary search to efficiently find the right position for each element</li>
            <li>Keep track of predecessor indices to reconstruct the subsequence at the end</li>
        </ul>
        
        <div class="visualization">
            <h3>Visualization of the Binary Search Approach</h3>
            <p>Let's consider the array [5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]:</p>
            <pre>
Initialize:
- indices array to store indices of elements in the LIS
- seq array to store predecessor indices
- length to track the current LIS length

Process:
- For each element, find its proper position in the current LIS
- Update the indices and seq arrays accordingly
- Track the maximum length found

Final step:
- Use the seq array to reconstruct the LIS starting from the last element
            </pre>
            <p>By carefully tracking the predecessors, we can rebuild the exact subsequence.</p>
        </div>
    </div>
    
    <!-- Implementation Section -->
    <div class="implementation">
        <h2>Implementation</h2>
        
        <h3>Approach 1: Backtracking - O(n²)</h3>
        <pre><code>## O(n^2)
class Info:
    def __init__(self, maxlen):
        self.maxlen = maxlen
        self.result = []
def longestIncreasingSubsequence(array):
    # Write your code here.
    maxL = 0
    n = len(array)
    if n <= 1:
        return array
    temp = []
    info = Info(0)
    LISS(array, 0, temp, info)
    return info.result

def LISS(array, index, temp, info):
    
    if info.maxlen < len(temp):
        info.maxlen = len(temp)
        info.result = temp[:]
        #return
    if index == len(array):
        return
    for i in range(index, len(array)):
        if len(temp)> 0 and temp[-1] >= array[i]:
            continue
        temp.append(array[i])
        LISS(array, i+1, temp, info)
        temp.pop()</code></pre>
        
        <div class="complexity">
            <h3>Time Complexity Analysis</h3>
            <p><strong>Time Complexity:</strong> O(2<sup>n</sup>) - Exponential</p>
            <ul>
                <li>This backtracking approach explores all possible subsequences</li>
                <li>In the worst case, we might consider all 2<sup>n</sup> possible subsequences</li>
                <li>This makes it inefficient for large input arrays</li>
            </ul>
            
            <p><strong>Space Complexity:</strong> O(n)</p>
            <ul>
                <li>We use recursion with a maximum depth of n</li>
                <li>We also store the subsequence, which could be of length n in the worst case</li>
                <li>Therefore, the space complexity is O(n)</li>
            </ul>
        </div>
        
        <div class="alternative">
            <h3>Approach 2: Dynamic Programming with Binary Search - O(n log n)</h3>
            <pre><code>### O(nlogn)
def longestIncreasingSubsequence1(array):
    m = len(array)
    indices = [None]*(m+1)
    seq = [None] * m
    length = 0
    for i , n in enumerate(array):
        index = binarySearch(indices, 1, length, array, n)
        seq[i] = indices[index-1]
        indices[index] = i
        length = max(length, index)
    return buildSubSequence(seq, array, indices[length])

def binarySearch(indices, startIndex, endIndex, array, n):
    
    while startIndex<= endIndex:
        mid = (startIndex + endIndex) //2
        
        if array[indices[mid]] < n:
            startIndex = mid+1
        else:
            endIndex = mid-1
    return startIndex

def buildSubSequence(seq, array, index):
    sub = []
    while index is not None:
        sub.append(array[index])
        index = seq[index]
    return list(reversed(sub))</code></pre>
            
            <p><strong>Time Complexity:</strong> O(n log n)</p>
            <ul>
                <li>We iterate through the array once, which is O(n)</li>
                <li>For each element, we perform a binary search which is O(log n)</li>
                <li>Reconstructing the subsequence at the end is O(n)</li>
                <li>Therefore, the overall time complexity is O(n log n)</li>
            </ul>
            
            <p><strong>Space Complexity:</strong> O(n)</p>
            <ul>
                <li>We use the indices and seq arrays, each of size O(n)</li>
                <li>The final subsequence can be at most of size n</li>
                <li>Therefore, the space complexity is O(n)</li>
            </ul>
        </div>
    </div>
    
    <!-- Testing Section -->
    <div class="implementation">
        <h2>Testing</h2>
        <div class="code-block">
            <div># Test Case 1 (Backtracking approach)</div>
            <div>array = [5, 7, -24, 12, 10, 2, 3, 12, 5, 6, 35]</div>
            <div>longestIncreasingSubsequence(array)  # Output: [-24, 2, 3, 5, 6, 35]</div>
            <div></div>
            <div># Test Case 2 (Backtracking approach)</div>
            <div>array = [3, 4, -1]</div>
            <div>longestIncreasingSubsequence(array)  # Output: [3, 4]</div>
            <div></div>
            <div># Test Case 3 (Binary Search approach)</div>
            <div>array = [3, 4, -1, 0]</div>
            <div>longestIncreasingSubsequence1(array)  # Output: [-1, 0]</div>
            <div></div>
            <div># Test Case 4 (Binary Search approach)</div>
            <div>array = [3, 4, -1]</div>
            <div>longestIncreasingSubsequence1(array)  # Output: [3, 4]</div>
        </div>
    </div>
    
    <!-- Related Problems Section -->
    <div class="approach">
        <h2>Related Problems</h2>
        <ul>
            <li><a href="https://pramodmodi.github.io/Datastructure/DS_html/LIS/Longest_Increasing_Subsequence.html">Longest Increasing Subsequence</a> - Finding the length of the longest increasing subsequence</li>
            <li><a href="https://pramodmodi.github.io/Datastructure/DS_html/LIS/Longest_Continuous_Increasing_Subsequence.html">Longest Continuous Increasing Subsequence</a> - Finding the longest subarray with strictly increasing elements</li>
            <li><a href="https://pramodmodi.github.io/Datastructure/DS_html/LIS/Number_of_Longest_Increasing_Subsequence.html">Number of Longest Increasing Subsequence</a> - Count how many different longest increasing subsequences exist</li>
            <li><a href="https://leetcode.com/problems/largest-divisible-subset/">Largest Divisible Subset</a> - A variation of LIS where elements form a divisible set</li>
            <li><a href="https://leetcode.com/problems/increasing-triplet-subsequence/">Increasing Triplet Subsequence</a> - A simplified version of LIS with fixed length</li>
        </ul>
    </div>
</body>
</html>
